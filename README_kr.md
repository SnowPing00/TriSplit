TriSplit: 3-스트림 분할 압축 엔진
TriSplit은 범용 압축기가 아닌, 특정 데이터 패턴에 고도로 특화된 압축 엔진입니다. 이 프로젝트의 핵심 철학은 **"분리하고, 변환하고, 정복하라(Divide, Transform, and Conquer)"**입니다.

데이터를 직접 압축하는 대신, 원본 데이터를 통계적으로 전혀 다른 특성을 가진 3개의 하위 스트림으로 지능적으로 분리합니다. 분리된 각 스트림은 후속 엔트로피 코더(rANS)가 최대의 효율을 발휘할 수 있도록 최적화된 형태로 변환됩니다. 이 접근법은 데이터에 숨겨진 구조를 드러내고, 각 구조에 가장 적합한 방식으로 압축을 수행하여 높은 압축률을 달성하는 것을 목표로 합니다.

3-스트림 분할 방식의 상세 설명
TriSplit은 원본 바이트 스트림을 2비트 단위의 심볼(00, 01, 10, 11)로 간주하고, 이를 통계적 특성에 따라 세 가지 스트림으로 재배치합니다.

스트림 1: value_bitmap (값 비트맵)
목적: 01과 10 심볼의 값 정보를 분리하여 저장합니다.

생성 방식:

원본 데이터에서 01 또는 10 심볼을 만날 때마다, 해당 심볼의 두 번째 비트 값을 이 스트림에 순서대로 기록합니다.

10을 만나면 0을, 01을 만나면 1을 저장합니다.

특징:

이 스트림은 0과 1의 빈도가 거의 유사한, 매우 단순한 이진(binary) 스트림이 됩니다.

rANS와 같은 엔트로피 코더는 이렇게 분포가 균일한 데이터를 매우 효율적으로 압축할 수 있습니다.

스트림 2: reconstructed_stream (재구성 스트림)
목적: 00/11 심볼의 정보와, 01/10 심볼의 위치 정보를 함께 보관합니다.

생성 방식:

원본 데이터에서 00 또는 11 심볼을 만나면, 해당 심볼의 첫 번째 비트(0)를 그대로 가져와 저장합니다.

원본 데이터에서 01 또는 10 심볼을 만나면, 이들의 위치를 표시하기 위한 "마커(marker)" 심볼(1)을 저장합니다.

특징:

이 스트림은 0 (원본 00/11 심볼)과 1 (마커) 두 종류의 비트로만 구성됩니다.

데이터의 구조적 정보를 담고 있으며, value_bitmap과 결합하여 01/10 심볼을 복원하는 데 사용됩니다.

스트림 3: auxiliary_mask (보조 마스크)
목적: 00과 11 심볼 중 더 드물게 나타나는 심볼의 위치를 기록합니다.

생성 방식:

압축 시작 전, 00과 11의 빈도를 계산하여 어떤 심볼이 더 희소한지 결정합니다.

reconstructed_stream을 생성할 때 00 또는 11 심볼을 만나는 지점에서, 만약 해당 심볼이 "희소 심볼"이라면 이 마스크 스트림에 1을 기록합니다. 그 외의 모든 위치에는 0이 기록됩니다.

특징:

이 스트림은 대부분이 0이고 간혹 1이 나타나는 **희소 비트 마스크(sparse bitmask)**가 됩니다.

이러한 희소 데이터는 rANS 코더가 극단적으로 높은 압축률을 달성할 수 있는 가장 이상적인 형태입니다.

압축 및 복호화 과정
압축:

SeparationEngine이 원본 데이터를 위의 3개 스트림으로 분리합니다.

rANS_Coder가 각 스트림의 통계적 특성에 맞춰 개별적으로 압축합니다.

압축된 3개의 스트림과 복호화에 필요한 메타데이터(원본 크기, 각 스트림의 압축된 크기 등)를 하나의 블록으로 묶어 저장합니다.

복호화:

압축된 블록에서 메타데이터를 읽어 각 스트림의 경계를 확인합니다.

rANS_Coder가 각 스트림을 병렬로 복호화하여 3개의 원본 스트림을 복원합니다.

SeparationEngine이 복원된 3개의 스트림을 조합하여 최종 원본 데이터를 완벽하게 재구성합니다.

왜 이 방식이 효과적인가?
단일 압축 알고리즘을 모든 데이터에 적용하는 것은 비효율적일 수 있습니다. TriSplit은 데이터를 여러 관점으로 "해체"하여 각 부분의 본질적인 특성을 드러냅니다.

value_bitmap은 순수한 정보를 분리합니다.

reconstructed_stream은 구조적 정보를 분리합니다.

auxiliary_mask는 예외적 정보를 분리합니다.

이렇게 분리되고 변환된 스트림들은 각각이 엔트로피 코딩에 매우 유리한 형태를 띠게 되므로, 전체적으로 높은 압축 효율을 달성할 수 있습니다.